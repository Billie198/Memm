<!DOCTYPE html>
<html lang="en">
<head>
<title>Matty's Ultimate Gem</title>
<style type="text/css">
body{font:16px/20px normal 'Helvetica Neue',Helvetica,Arial,sans-serif;margin:0;padding:16px;background:#fff;color:#000}
#license{font:12px/14px normal 'Andale Mono',monospace;margin:1em 0;padding:12px;background:#d8d8d8;color:#000}
h1{font:32px/48px normal;color:#6c6c6c}
h2{font-size:22px;font-weight:normal;margin:2em 0 1.2em;border:1px solid #bbb;border-radius:3px;padding:0.75em 0.5em;background:#dedede}
h3{font-size:32px;font-weight:normal;color:#6c6c6c}
h4{font-size:18px;font-weight:bold;}
</style>
<link rel="stylesheet" href="highlight.js/styles/default.css">
<script src="highlight.js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
<h1>Matty&#39;s Ultimate Gem</h1>

<p><a href="http://travis-ci.org/phluid61/mug"><img src="https://secure.travis-ci.org/phluid61/mug.png" alt="Build Status"></a><br>
<a href="http://badge.fury.io/rb/mug"><img src="https://badge.fury.io/rb/mug.png" alt="Gem Version"></a></p>

<h2>and-or</h2>

<h3>Object</h3>

<h4><code>obj.and default</code></h4>

<h4><code>obj.and default {|o| block }</code></h4>

<p>Returns either <em>obj</em> or <em>default</em>, depending on the falsiness of <em>obj</em>.</p>

<p>If a block is given, <em>obj</em> is yielded to it; if it returns truthy, <em>default</em> is returned, otherwise <em>obj</em> is returned.</p>

<h4><code>obj.or default</code></h4>

<h4><code>obj.or default {|o| block }</code></h4>

<p>Returns either <em>obj</em> or <em>default</em>, depending on the truthiness of <em>obj</em>.</p>

<p>If a block is given, <em>obj</em> is yielded to it; if it returns truthy, <em>obj</em> is returned, otherwise <em>default</em> is returned.</p>

<h3>Examples</h3>

<pre lang="ruby"><code>require &#39;mug/and-or&#39;

data_store.get_env_hash.or(default_hash).do_something

get_a_list.and(default_list, &amp;:empty?).do_something
</code></pre>

<h2>apply</h2>

<h3>Proc</h3>

<h4><code>proc.apply *args</code></h4>

<p>Curries this Proc and partially applies parameters.<br>
If a sufficient number of arguments are supplied, it passes the<br>
supplied arguments to the original proc and returns the result.<br>
Otherwise, returns another curried proc that takes the rest of<br>
arguments.</p>

<h3>Method</h3>

<h4><code>meth.curry</code></h4>

<h4><code>meth.curry n</code></h4>

<p>Returns a curried proc. If the optional arity argument is given,<br>
it determines the number of arguments. A curried proc receives<br>
some arguments. If a sufficient number of arguments are supplied,<br>
it passes the supplied arguments to the original proc and returns<br>
the result. Otherwise, returns another curried proc that takes the<br>
rest of arguments.</p>

<h4><code>meth.apply *args</code></h4>

<p>Curries this Method and partially applies parameters.<br>
If a sufficient number of arguments are supplied, it passes the<br>
supplied arguments to the original proc and returns the result.<br>
Otherwise, returns another curried proc that takes the rest of<br>
arguments.</p>

<h2>array/extend</h2>

<h3>Array</h3>

<h4>`array.extend!(size=0, obj=nil)</h4>

<h4><code>array.extend!(array)</code></h4>

<h4><code>array.extend!(size) {|index| block }</code></h4>

<p>Extend this Array.</p>

<p>In the first form, when a <em>size</em> and an optional <em>obj</em> are sent,<br>
the array is extended with <em>size</em> copies of <em>obj</em>. Take notice that<br>
all elements will reference the same object <em>obj</em>.</p>

<p>The second form appends a copy of the array passed as a parameter<br>
(the array is generated by calling <code>#to_ary</code> on the parameter).<br>
See also: <code>#concat</code>, <code>#+</code></p>

<p>In the last form, the array is extended by the given size. Each new<br>
element in the array is created by passing the element&#39;s index to the<br>
given block and storing the return value.</p>

<h4>`array.extend(size=0, obj=nil)</h4>

<h4><code>array.extend(array)</code></h4>

<h4><code>array.extend(size) {|index| block }</code></h4>

<p>See <code>#extend!</code></p>

<h2>bool</h2>

<h3>Kernel</h3>

<h4><code>Bool(obj)</code></h4>

<p>Returns the truthiness of <em>obj</em>, as either <em>True</em> or <em>False</em>.</p>

<p>This is functionally equivalent to calling <code>!!obj</code></p>

<h3>Object</h3>

<h4><code>obj.to_b</code></h4>

<p>Converts <em>obj</em> to a boolean using &quot;typical&quot; C-like conversion rules.</p>

<p>The following values all become false:</p>

<ul>
<li><code>0</code>, <code>0.0</code>, etc. (any numeric zero)</li>
<li><code>Float::NAN</code></li>
<li><code>&quot;&quot;</code></li>
<li><code>[]</code>, <code>{}</code>, etc. (any Enumerable or Enumerator with no elements)</li>
<li>any Exception</li>
</ul>

<p>All others values become true.</p>

<h4><code>obj.to_bool</code></h4>

<p>Returns the truthiness of <em>obj</em>, as either <em>True</em> or <em>False</em>.</p>

<p>This is functionally equivalent to calling <code>!!obj</code></p>

<h3>Examples</h3>

<pre lang="ruby"><code>require &#39;mug/bool&#39;

Bool(obj) #=&gt; !!obj
obj.to_bool #=&gt; !!obj
obj.to_b #=&gt; C-like truthiness
</code></pre>

<h2>fragile-method-chain</h2>

<p>Defines a fragile method chain.  If any method call in the chain returns a falsy value, the chain aborts.</p>

<pre lang="ruby"><code>require &#39;mug/fragile-method-chain&#39;

# Similar to: a.b &amp;&amp; a.b.c
# except that a.b is not called twice
a._?.b.c._!

# Also works with #[] method
nested_hash._?[:a][:b][:c]._!
</code></pre>

<h2>hash/map</h2>

<h3>Hash</h3>

<h4><code>hsh.map_values {|v| block }</code></h4>

<p>Returns a new hash which is a copy of +hsh+ but each value is replaced by the result of running it through +block+.</p>

<pre lang="ruby"><code>require &#39;mug/hash/map&#39;

{&#39;a&#39;=&gt;1, &#39;b&#39;=&gt;2}.map_values { |v| v*2 } #=&gt; {&#39;a&#39;=&gt;2, &#39;b&#39;=&gt;4}
{&#39;a&#39;=&gt;1, &#39;b&#39;=&gt;2}.map_values { &quot;cat&quot; }   #=&gt; {&#39;a&#39;=&gt;&quot;cat&quot;, &#39;b&#39;=&gt;&quot;cat&quot;}
</code></pre>

<h4><code>hsh.map_keys {|k| block }</code></h4>

<p>Returns a new hash which is a copy of +hsh+ but each key is replaced by the result of running it through +block+.</p>

<p>If +block+ returns duplicate keys, they will be overwritten in the resulting hash.</p>

<pre lang="ruby"><code>require &#39;mug/hash/map&#39;

{&#39;a&#39;=&gt;1, &#39;b&#39;=&gt;2}.map_keys { |k| k*2 } #=&gt; {&#39;aa&#39;=&gt;1, &#39;bb&#39;=&gt;2}
{&#39;a&#39;=&gt;1, &#39;b&#39;=&gt;2}.map_keys { &quot;cat&quot; }   #=&gt; {&#39;cat&#39;=&gt;2}
</code></pre>

<h4><code>hsh.map_pairs {|k, v| block }</code></h4>

<p>Returns a new hash which is a copy of +hsh+ but each key-value pair is replaced by the result of running it through +block+.</p>

<p>If +block+ returns duplicate keys, they will be overwritten in the resulting hash.</p>

<pre lang="ruby"><code>require &#39;mug/hash/map&#39;

{&#39;a&#39;=&gt;1, &#39;b&#39;=&gt;2}.map_pairs { |k,v| [k*2, v+1] } #=&gt; {&#39;aa&#39;=&gt;2, &#39;bb&#39;=&gt;3}
{&#39;a&#39;=&gt;1, &#39;b&#39;=&gt;2}.map_pairs { [&quot;cat&quot;,&quot;dog&quot;] }   #=&gt; {&#39;cat&#39;=&gt;&#39;dog&#39;}
</code></pre>

<h2>hash/operations</h2>

<h3>Hash</h3>

<h4><code>hsh | other_hsh</code></h4>

<p>Returns a new Hash, whose value is the same as this<br>
one, with any extras in +other_hash+ added in.</p>

<p>Useful for default options.</p>

<pre lang="ruby"><code>require &#39;mug/hash/operations&#39;

def foo options={}
  options | {b: 2, c: 2}
end
foo a: 1, b: 1 # =&gt; {:a=&gt;1, :b=&gt;1, :c=&gt;2}
</code></pre>

<h4><code>hsh + other_hsh</code></h4>

<p>Adds the contents of +other_hash+ to +hsh+.<br>
Entries with duplicate keys are overwritten with the values from +other_hash+</p>

<pre lang="ruby"><code>require &#39;mug/hash/operations&#39;

a = {a: 1, b: 1}
b = {b: 2, c: 2}
a + b # =&gt; {:a=&gt;1, :b=&gt;2, :c=&gt;2}
b + a # =&gt; {:a=&gt;1, :b=&gt;1, :c=&gt;2}
</code></pre>

<h4><code>hsh &lt;&lt; o</code></h4>

<p>Appends stuff to the hash.</p>

<ul>
<li>If +o+ is a Hash, this is identical to calling #merge!</li>
<li>If +o+ is an Array with two elements, it is interpreted as [key,value]</li>
<li>If +o+ can be converted to a hash with #to_h, this is identical to calling #merge!</li>
<li>Otherwise an ArgumentError is raised.</li>
</ul>

<pre lang="ruby"><code>require &#39;mug/hash/operations&#39;

h = {}
h &lt;&lt; {:a=&gt;0}       # h = {:a=&gt;0}
h &lt;&lt; {:b=&gt;2,:c=&gt;3} # h = {:a=&gt;0,:b=&gt;2,:c=&gt;3}
h &lt;&lt; [:a,1]        # h = {:a=&gt;1,:b=&gt;2,:c=&gt;3}
</code></pre>

<h2>iterator/for</h2>

<h3>Object</h3>

<h4><code>obj.iter_for(meth, *args)</code></h4>

<p>Creates an Iterator object, which is a subclass of Enumerator that recursively invokes a method on an object.</p>

<p>Initially the receiving object is +obj+.  After each iteration, the receiving object is replaced with the result of the previous iteration.</p>

<pre lang="ruby"><code>require &#39;mug/iterator/for&#39;

0.iter_for(:next).take(5) #=&gt; [0,1,2,3,4]
0.iter_for(:+,2).take(5) #=&gt; [0,2,4,6,8]
</code></pre>

<h2>iterator/method</h2>

<h3>Method</h3>

<h4><code>meth.to_iter(*args)</code></h4>

<p>Creates an Iterator object, which is a subclass of Enumerator that recursively invokes +meth+ on an object.</p>

<p>Initially the receiving object is the object on which +meth+ is defined.  After each iteration, the receiving object is replaced with the result of the previous iteration.</p>

<pre lang="ruby"><code>require &#39;mug/iterator/method&#39;

0.method(:next).to_iter.take(5) #=&gt; [0,1,2,3,4]
0.method(:+).to_iter(2).take(5) #=&gt; [0,2,4,6,8]
</code></pre>

<h2>maybe</h2>

<h3>Object</h3>

<h4><code>obj.maybe</code></h4>

<h4><code>obj.maybe { block }</code></h4>

<p>Invokes a method on +obj+ iff +obj+ is truthy, otherwise returns +obj+.</p>

<p>When a block is given, the block is invoked in the scope of +obj+ (i.e. <code>self</code> in the block refers to +obj+).</p>

<p>When no block is given, <code>maybe</code> returns an object to conditionally delegates methods to +obj+.</p>

<pre lang="ruby"><code>require &#39;mug/maybe&#39;

# Equivalent to: a &amp;&amp; a.b &amp;&amp; a.b.c
# except that a and b are only invoked once

# (block form)
a.maybe{ b.maybe{ c } }

# (delegator form)
a.maybe.b.maybe.c
</code></pre>

<h2>self</h2>

<h3>Object</h3>

<h4><code>obj.self</code></h4>

<h4><code>obj.self {|o| block }</code></h4>

<p>When a block is given, yields +obj+ to the block and returns the resulting value.</p>

<p>When no block is given, simply returns +obj+.</p>

<blockquote>
<p>Note: this is different from <code>#tap</code> because <code>obj.tap{nil}</code> returns <code>obj</code>, but <code>obj.self{nil}</code> returns <code>nil</code>.</p>
</blockquote>

<pre lang="ruby"><code>require &#39;mug/self&#39;

1.self #=&gt; 1
obj.self #=&gt; obj
2.self{|i| i*3 } #=&gt; 6
[1,1,2,2,3].group_by(&amp;:self) #=&gt; {1=&gt;[1,1], 2=&gt;[2,2], 3=&gt;[3]}
</code></pre>

<h2>tau</h2>

<p>Defines the true circle constant.</p>

<pre lang="ruby"><code>Math::TAU #= 6.283185307179586..
</code></pre>

<p>Additionally it expands the BigDecimal/BigMath module:</p>

<pre lang="ruby"><code>require &#39;bigdecimal&#39;
require &#39;bigdecimal/math&#39;
include BigMath

puts TAU(15)
</code></pre>

<p>See <a href="http://tauday.com">http://tauday.com</a> to find out what it&#39;s all about.</p>

<h2>to_h</h2>

<blockquote>
<p>Note: for Ruy 2.1, <code>Enumerable#to_h</code> <a href="http://ruby-doc.org/core-2.1.0/Enumerable.html#method-i-to_h">is already defined</a> in a similar but <em>not identical</em> way.  Please take care when mixing this gem with Ruby &gt;=2.1.</p>

<p>Note: for Ruby &lt;2.0, it is advisable to also include the <a href="https://rubygems.org/gems/to_h"><em>to_h</em> gem</a>.</p>
</blockquote>

<h3>Enumerable</h3>

<h4><code>enum.to_h</code></h4>

<p>Converts <em>enum</em> to a hash.</p>

<p>Each element of <em>enum</em> must be a single item, or an array of two items.  Duplicate keys are overwritten in order.</p>

<pre lang="ruby"><code>[].to_h             #=&gt; {}
[1,2].to_h          #=&gt; {1=&gt;nil, 2=&gt;nil}
(1..2).to_h         #=&gt; {1=&gt;nil, 2=&gt;nil}
[[1,2],[3,4]].to_h  #=&gt; {1=&gt;2, 3=&gt;4}
[[1,2],[1,4]].to_h  #=&gt; {1=&gt;4}
</code></pre>
<pre id="license" class="no-highlight">Copyright (c) 2013, Matthew Kerwin <matthew@kerwin.net.au>Permission to use, copy, modify, and/or distribute this software for anypurpose with or without fee is hereby granted, provided that the abovecopyright notice and this permission notice appear in all copies.THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIESWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OFMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FORANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGESWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN ANACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OFOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</pre></body>
</html>
