<!DOCTYPE html>
<html lang="en">
<head>
<title>Matty's Ultimate Gem</title>
<style type="text/css">
body{font:16px/20px normal 'Helvetica Neue',Helvetica,Arial,sans-serif;margin:0;padding:16px;background:#fff;color:#000}
#license{font:12px/14px normal 'Andale Mono',monospace;margin:1em 0;padding:12px;background:#d8d8d8;color:#000}
h1{font:32px/48px normal;color:#6c6c6c}
h2{font-size:22px;font-weight:normal;margin:2em 0 1.2em;border:1px solid #bbb;border-radius:3px;padding:0.75em 0.5em;background:#dedede}
h3{font-size:32px;font-weight:normal;color:#6c6c6c}
h4{font-size:18px;font-weight:bold;}
</style>
<link rel="stylesheet" href="highlight.js/styles/default.css">
<script src="highlight.js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
<h1>Matty&#39;s Ultimate Gem</h1>

<p><a href="http://travis-ci.org/phluid61/mug"><img src="https://secure.travis-ci.org/phluid61/mug.png" alt="Build Status"></a><br>
<a href="http://badge.fury.io/rb/mug"><img src="https://badge.fury.io/rb/mug.png" alt="Gem Version"></a></p>

<h2>and-or</h2>

<h3>Object</h3>

<h4><code>obj.and default</code></h4>

<h4><code>obj.and default {|o| block }</code></h4>

<p>Returns either <em>obj</em> or <em>default</em>, depending on the falsiness of <em>obj</em>.</p>

<p>If a block is given, <em>obj</em> is yielded to it; if it returns truthy, <em>default</em> is returned, otherwise <em>obj</em> is returned.</p>

<h4><code>obj.or default</code></h4>

<h4><code>obj.or default {|o| block }</code></h4>

<p>Returns either <em>obj</em> or <em>default</em>, depending on the truthiness of <em>obj</em>.</p>

<p>If a block is given, <em>obj</em> is yielded to it; if it returns truthy, <em>obj</em> is returned, otherwise <em>default</em> is returned.</p>

<h3>Examples</h3>

<pre lang="ruby"><code>require &#39;mug/and-or&#39;

data_store.get_env_hash.or(default_hash).do_something

get_a_list.and(default_list, &amp;:empty?).do_something
</code></pre>

<h2>apply</h2>

<h3>Proc</h3>

<h4><code>proc.apply *args</code></h4>

<p>Curries this Proc and partially applies parameters.<br>
If a sufficient number of arguments are supplied, it passes the<br>
supplied arguments to the original proc and returns the result.<br>
Otherwise, returns another curried proc that takes the rest of<br>
arguments.</p>

<h3>Method</h3>

<h4><code>meth.curry</code></h4>

<h4><code>meth.curry n</code></h4>

<p>Returns a curried proc. If the optional arity argument is given,<br>
it determines the number of arguments. A curried proc receives<br>
some arguments. If a sufficient number of arguments are supplied,<br>
it passes the supplied arguments to the original proc and returns<br>
the result. Otherwise, returns another curried proc that takes the<br>
rest of arguments.</p>

<h4><code>meth.apply *args</code></h4>

<p>Curries this Method and partially applies parameters.<br>
If a sufficient number of arguments are supplied, it passes the<br>
supplied arguments to the original proc and returns the result.<br>
Otherwise, returns another curried proc that takes the rest of<br>
arguments.</p>

<h2>array/extend</h2>

<h3>Array</h3>

<h4><code>array.extend!(size=0, obj=nil)</code></h4>

<h4><code>array.extend!(array)</code></h4>

<h4><code>array.extend!(size) {|index| block }</code></h4>

<p>Extend this Array.</p>

<p>In the first form, when a <em>size</em> and an optional <em>obj</em> are sent,<br>
the array is extended with <em>size</em> copies of <em>obj</em>. Take notice that<br>
all elements will reference the same object <em>obj</em>.</p>

<p>The second form appends a copy of the array passed as a parameter<br>
(the array is generated by calling <code>#to_ary</code> on the parameter).<br>
See also: <code>#concat</code>, <code>#+</code></p>

<p>In the last form, the array is extended by the given size. Each new<br>
element in the array is created by passing the element&#39;s index to the<br>
given block and storing the return value.</p>

<h4><code>array.extend(size=0, obj=nil)</code></h4>

<h4><code>array.extend(array)</code></h4>

<h4><code>array.extend(size) {|index| block }</code></h4>

<p>See <code>#extend!</code></p>

<h2>array/minus</h2>

<h3>Array</h3>

<h4><code>array.minus(ary, remainder: false)</code></h4>

<p>Subtract elements from this array.</p>

<p>This is similar to <code>Array#-</code> except that elements from this array are<br>
removed only once per instance in <em>ary</em>.</p>

<p>If <em>remainder</em> is given and true, returns a second array which is<br>
all elements in <em>ary</em> that were not present in this array.</p>

<h2>bool</h2>

<h3>Kernel</h3>

<h4><code>Bool(obj)</code></h4>

<p>Returns the truthiness of <em>obj</em>, as either <em>True</em> or <em>False</em>.</p>

<p>This is functionally equivalent to calling <code>!!obj</code></p>

<h3>Object</h3>

<h4><code>obj.to_b</code></h4>

<p>Converts <em>obj</em> to a boolean using &quot;typical&quot; C-like conversion rules.</p>

<p>The following values all become false:</p>

<ul>
<li><code>0</code>, <code>0.0</code>, etc. (any numeric zero)</li>
<li><code>Float::NAN</code></li>
<li><code>&quot;&quot;</code></li>
<li><code>[]</code>, <code>{}</code>, etc. (any Enumerable or Enumerator with no elements)</li>
<li>any Exception</li>
</ul>

<p>All others values become true.</p>

<h4><code>obj.to_bool</code></h4>

<p>Returns the truthiness of <em>obj</em>, as either <em>True</em> or <em>False</em>.</p>

<p>This is functionally equivalent to calling <code>!!obj</code></p>

<h3>Examples</h3>

<pre lang="ruby"><code>require &#39;mug/bool&#39;

Bool(obj) #=&gt; !!obj
obj.to_bool #=&gt; !!obj
obj.to_b #=&gt; C-like truthiness
</code></pre>

<h2>clamp</h2>

<p>Clamps a number to a range.</p>

<h3>Numeric</h3>

<h4><code>num.clamp lower, higher =&gt; new\_num</code></h4>

<p>Clamps <em>num</em> so that <em>lower</em> &lt;= <em>new_num</em> &lt;= <em>higher</em>.</p>

<p>Returns <em>lower</em> when <em>num</em> &lt; <em>lower</em>, <em>higher</em> when <em>num</em> &gt; <em>higher</em>, otherwise<br>
<em>num</em> itself.</p>

<p>Raises an exception if <em>lower</em> &gt; <em>higher</em></p>

<h4><code>num.clamp range =&gt; new\_num</code></h4>

<p>Effectively calls range#bound</p>

<h3>Range</h3>

<h4><code>rng.bound val =&gt; new\_val</code></h4>

<p>Bounds val so that <em>first</em> &lt;= <em>new_val</em> &lt;= <em>last</em>.</p>

<p>Returns <em>first</em> when <em>val</em> &lt; <em>first</em>, <em>last</em> when <em>val</em> &gt; <em>last</em>, otherwise<br>
<em>val</em> itself.</p>

<p>Raises an exception if <em>val</em> &gt;= <em>end</em> and the range is exclusive.</p>

<h2>counts</h2>

<p>Returns counts of objects in enumerables.</p>

<h3>Enumerable</h3>

<h4><code>enum.counts</code></h4>

<p>Returns a hash of <code>item=&gt;count</code> showing how many<br>
of each <em>item</em> are in this Enumerable.</p>

<h4><code>enum.counts_by {|item| block }</code></h4>

<p>Passes each element in turn to the block, and returns a<br>
hash of <code>result=&gt;count</code>.</p>

<p>If no block is given, an enumerator is returned.</p>

<h3>Examples</h3>

<pre lang="ruby"><code>require &#39;mug/counts&#39;

%w(a b b).counts                   #=&gt; {&#39;a&#39;=&gt;1, &#39;b&#39;=&gt;2}
%w(a b b).counts_by{|o| o.upcase } #=&gt; {&#39;A&#39;=&gt;1, &#39;B&#39;=&gt;2}
</code></pre>

<h2>fragile-method-chain</h2>

<p>Defines a fragile method chain.  If any method call in the chain returns a falsy value, the chain aborts.</p>

<pre lang="ruby"><code>require &#39;mug/fragile-method-chain&#39;

# Similar to: a.b &amp;&amp; a.b.c
# except that a.b is not called twice
a._?.b.c._!

# Also works with #[] method
nested_hash._?[:a][:b][:c]._!
</code></pre>

<h2>hash/map</h2>

<h3>Hash</h3>

<h4><code>hsh.map_values {|v| block }</code></h4>

<p>Returns a new hash which is a copy of <em>hsh</em> but each value is replaced by the result of running it through <em>block</em>.</p>

<pre lang="ruby"><code>require &#39;mug/hash/map&#39;

{&#39;a&#39;=&gt;1, &#39;b&#39;=&gt;2}.map_values { |v| v*2 } #=&gt; {&#39;a&#39;=&gt;2, &#39;b&#39;=&gt;4}
{&#39;a&#39;=&gt;1, &#39;b&#39;=&gt;2}.map_values { &quot;cat&quot; }   #=&gt; {&#39;a&#39;=&gt;&quot;cat&quot;, &#39;b&#39;=&gt;&quot;cat&quot;}
</code></pre>

<h4><code>hsh.map_keys {|k| block }</code></h4>

<p>Returns a new hash which is a copy of <em>hsh</em> but each key is replaced by the result of running it through <em>block</em>.</p>

<p>If <em>block</em> returns duplicate keys, they will be overwritten in the resulting hash.</p>

<pre lang="ruby"><code>require &#39;mug/hash/map&#39;

{&#39;a&#39;=&gt;1, &#39;b&#39;=&gt;2}.map_keys { |k| k*2 } #=&gt; {&#39;aa&#39;=&gt;1, &#39;bb&#39;=&gt;2}
{&#39;a&#39;=&gt;1, &#39;b&#39;=&gt;2}.map_keys { &quot;cat&quot; }   #=&gt; {&#39;cat&#39;=&gt;2}
</code></pre>

<h4><code>hsh.map_pairs {|k, v| block }</code></h4>

<p>Returns a new hash which is a copy of <em>hsh</em> but each key-value pair is replaced by the result of running it through <em>block</em>.</p>

<p>If <em>block</em> returns duplicate keys, they will be overwritten in the resulting hash.</p>

<pre lang="ruby"><code>require &#39;mug/hash/map&#39;

{&#39;a&#39;=&gt;1, &#39;b&#39;=&gt;2}.map_pairs { |k,v| [k*2, v+1] } #=&gt; {&#39;aa&#39;=&gt;2, &#39;bb&#39;=&gt;3}
{&#39;a&#39;=&gt;1, &#39;b&#39;=&gt;2}.map_pairs { [&quot;cat&quot;,&quot;dog&quot;] }   #=&gt; {&#39;cat&#39;=&gt;&#39;dog&#39;}
</code></pre>

<h2>hash/operations</h2>

<h3>Hash</h3>

<h4><code>hsh | other_hsh</code></h4>

<p>Returns a new Hash, whose value is the same as this<br>
one, with any extras in <em>other_hash</em> added in.</p>

<p>Useful for default options.</p>

<pre lang="ruby"><code>require &#39;mug/hash/operations&#39;

def foo options={}
  options | {b: 2, c: 2}
end
foo a: 1, b: 1 # =&gt; {:a=&gt;1, :b=&gt;1, :c=&gt;2}
</code></pre>

<h4><code>hsh + other_hsh</code></h4>

<p>Adds the contents of <em>other_hash</em> to <em>hsh</em>.<br>
Entries with duplicate keys are overwritten with the values from <em>other_hash</em></p>

<pre lang="ruby"><code>require &#39;mug/hash/operations&#39;

a = {a: 1, b: 1}
b = {b: 2, c: 2}
a + b # =&gt; {:a=&gt;1, :b=&gt;2, :c=&gt;2}
b + a # =&gt; {:a=&gt;1, :b=&gt;1, :c=&gt;2}
</code></pre>

<h4><code>hsh &lt;&lt; o</code></h4>

<p>Appends stuff to the hash.</p>

<ul>
<li>If <em>o</em> is a Hash, this is identical to calling #merge!</li>
<li>If <em>o</em> is an Array with two elements, it is interpreted as [key,value]</li>
<li>If <em>o</em> can be converted to a hash with #to_h, this is identical to calling #merge!</li>
<li>Otherwise an ArgumentError is raised.</li>
</ul>

<pre lang="ruby"><code>require &#39;mug/hash/operations&#39;

h = {}
h &lt;&lt; {:a=&gt;0}       # h = {:a=&gt;0}
h &lt;&lt; {:b=&gt;2,:c=&gt;3} # h = {:a=&gt;0,:b=&gt;2,:c=&gt;3}
h &lt;&lt; [:a,1]        # h = {:a=&gt;1,:b=&gt;2,:c=&gt;3}
</code></pre>

<h2>iterator/for</h2>

<h3>Object</h3>

<h4><code>obj.iter_for(meth, *args)</code></h4>

<p>Creates an Iterator object, which is a subclass of Enumerator that recursively invokes a method on an object.</p>

<p>Initially the receiving object is <em>obj</em>.  After each iteration, the receiving object is replaced with the result of the previous iteration.</p>

<pre lang="ruby"><code>require &#39;mug/iterator/for&#39;

0.iter_for(:next).take(5) #=&gt; [0,1,2,3,4]
0.iter_for(:+,2).take(5) #=&gt; [0,2,4,6,8]
</code></pre>

<h2>iterator/method</h2>

<h3>Method</h3>

<h4><code>meth.to_iter(*args)</code></h4>

<p>Creates an Iterator object, which is a subclass of Enumerator that recursively invokes <em>meth</em> on an object.</p>

<p>Initially the receiving object is the object on which <em>meth</em> is defined.  After each iteration, the receiving object is replaced with the result of the previous iteration.</p>

<pre lang="ruby"><code>require &#39;mug/iterator/method&#39;

0.method(:next).to_iter.take(5) #=&gt; [0,1,2,3,4]
0.method(:+).to_iter(2).take(5) #=&gt; [0,2,4,6,8]
</code></pre>

<h2>loop-with</h2>

<h3>Kernel</h3>

<h4><code>loop_with_index(offset=0) {|i| block }</code></h4>

<p>Repeatedly executes the block, yielding the current iteration<br>
count, which starts from <em>offset</em>. If no block is given, returns<br>
a new Enumerator that includes the iteration count, starting<br>
from <em>offset</em></p>

<h4><code>loop_with_object(obj) {|o| block }</code></h4>

<p>Repeatedly executes the block, yielding an arbitrary object, <em>obj</em>.</p>

<h3>Examples</h3>

<pre lang="ruby"><code>require &#39;mug/loop-with&#39;

loop_with_index do |i|
  p i
  break
end

arr = loop_with_object([]) do |a|
  s = gets.chomp
  throw StopIteration if s.empty?
  a &lt;&lt; s
end
</code></pre>

<h2>maybe</h2>

<h3>Object</h3>

<h4><code>obj.maybe</code></h4>

<h4><code>obj.maybe { block }</code></h4>

<p>Invokes a method on <em>obj</em> iff <em>obj</em> is truthy, otherwise returns <em>obj</em>.</p>

<p>When a block is given, the block is invoked in the scope of <em>obj</em> (i.e. <code>self</code> in the block refers to <em>obj</em>).</p>

<p>When no block is given, <em>maybe</em> returns an object to conditionally delegates methods to <em>obj</em>.</p>

<pre lang="ruby"><code>require &#39;mug/maybe&#39;

# Equivalent to: a &amp;&amp; a.b &amp;&amp; a.b.c
# except that a and b are only invoked once

# (block form)
a.maybe{ b.maybe{ c } }

# (delegator form)
a.maybe.b.maybe.c
</code></pre>

<h2>negativity</h2>

<h3>Numeric</h3>

<h4><code>num.negative?</code></h4>

<p>If <em>num</em> is negative (i.e. &lt; 0), returns itself, otherwise returns <em>nil</em>.</p>

<h4><code>num.positive?</code></h4>

<p>If <em>num</em> is positive (i.e. &gt; 0), returns itself, otherwise returns <em>nil</em>.</p>

<h4><code>num.nonnegative?</code></h4>

<p>If <em>num</em> is nonnegative (i.e. &gt;= 0), returns itself, otherwise returns <em>nil</em>.</p>

<h4><code>num.nonpositive?</code></h4>

<p>If <em>num</em> is nonpositive (i.e. &lt;= 0), returns itself, otherwise returns <em>nil</em>.</p>

<h3>Examples</h3>

<pre lang="ruby"><code>require &#39;mug/negativity&#39;

if i.negative?
  puts &quot;#{i} = 0 - #{-i}&quot;
end

n.positive? or raise(&#39;not enough items&#39;)

x.nonnegative? || -x

arr.map{|i| i.nonpositive? }.compact
</code></pre>

<h2>rexproc</h2>

<h3>Regexp</h3>

<h4><code>rex.to_proc</code></h4>

<p>Returns a proc that accepts one argument, that matches against this regexp object.</p>

<pre lang="ruby"><code>require &#39;mug/rexproc&#39;

%w[foo bar baz].select &amp;/\Ab/ #=&gt; [&quot;bar&quot;, &quot;baz&quot;]
%w[foo bar baz].reject &amp;/\Ab/ #=&gt; [&quot;foo&quot;]
%w[foo bar baz].find &amp;/\Ab/ #=&gt; &quot;bar&quot;
</code></pre>

<h2>self</h2>

<h3>Object</h3>

<h4><code>obj.self</code></h4>

<h4><code>obj.self {|o| block }</code></h4>

<h4><code>obj.itself</code></h4>

<h4><code>obj.itself {|o| block }</code></h4>

<p>When a block is given, yields <em>obj</em> to the block and returns the resulting value.</p>

<p>When no block is given, simply returns <em>obj</em>.</p>

<blockquote>
<p>Note: this is different from <code>#tap</code> because <code>obj.tap{nil}</code> returns <em>obj</em>, but <code>obj.self{nil}</code> returns <em>nil</em>.</p>
</blockquote>

<pre lang="ruby"><code>require &#39;mug/self&#39;

1.self #=&gt; 1
obj.self #=&gt; obj
2.self{|i| i*3 } #=&gt; 6
[1,1,2,2,3].group_by(&amp;:self) #=&gt; {1=&gt;[1,1], 2=&gt;[2,2], 3=&gt;[3]}

1.itself #=&gt; 1
obj.itself #=&gt; obj
2.itself{|i| i*3 } #=&gt; 6
[1,1,2,2,3].group_by(&amp;:itself) #=&gt; {1=&gt;[1,1], 2=&gt;[2,2], 3=&gt;[3]}
</code></pre>

<h4><code>obj.revapply(*args) {|*list| block }</code></h4>

<h4><code>obj.revapply(*args)</code></h4>

<p>When a block is given, yields <em>obj</em> and any <em>args</em> to the block and returns the resulting value.</p>

<p>When no block is given, returns an Enumerator.</p>

<h2>tau</h2>

<p>Defines the true circle constant.</p>

<pre lang="ruby"><code>Math::TAU #= 6.283185307179586..
</code></pre>

<p>Additionally it expands the BigDecimal/BigMath module:</p>

<pre lang="ruby"><code>require &#39;bigdecimal&#39;
require &#39;bigdecimal/math&#39;
include BigMath

puts TAU(15)
</code></pre>

<p>See <a href="http://tauday.com">http://tauday.com</a> to find out what it&#39;s all about.</p>

<h2>to_h</h2>

<p><strong>Removed</strong></p>

<blockquote>
<p>Note: for Ruy 2.1, <code>Enumerable#to_h</code> <a href="http://ruby-doc.org/core-2.1.0/Enumerable.html#method-i-to_h">is already defined</a>.</p>

<p>Note: for Ruby &lt;2.0, it is advisable to instead use the <a href="https://rubygems.org/gems/to_h"><em>to_h</em> gem</a>.</p>
</blockquote>

<h2>top</h2>

<h3>Enumerable</h3>

<h4><code>enum.top(n=1)</code></h4>

<h4><code>enum.top(n=1) {|a,b| block }</code></h4>

<p>Get the top <em>n</em> items, in order from top to bottom.</p>

<p>Returns an <em>Array</em> even when <em>n</em> is 1.</p>

<p>See: <code>Enumerable#sort</code></p>

<h4><code>enum.top_by(n=1) {|item| block }</code></h4>

<p>Get the top <em>n</em> items, in order from top to bottom, ordered<br>
by mapping the values through the given block.</p>

<p>Returns an <em>Array</em> even when <em>n</em> is 1. Values that are tied<br>
after mapping are returned in the initial order.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<p>See: <code>Enumerable#sort_by</code></p>

<h4><code>enum.bottom(n=1)</code></h4>

<h4><code>enum.bottom(n=1) {|a,b| block }</code></h4>

<p>Get the bottom <em>n</em> items, in order from bottom to top.</p>

<p>Returns an <em>Array</em> even when <em>n</em> is 1.</p>

<p>See: <code>Enumerable#sort</code></p>

<h4><code>enum.bottom_by(n=1) {|item| item }</code></h4>

<p>Get the bottom <em>n</em> items, in order from bottom to top, ordered<br>
by mapping the values through the given block.</p>

<p>Returns an <em>Array</em> even when <em>n</em> is 1. Values that are tied<br>
after mapping are returned in the initial order.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<p>See: <code>Enumerable#sort_by</code></p>
<pre id="license" class="no-highlight">Copyright (c) 2013-2015, Matthew Kerwin <matthew@kerwin.net.au>Permission to use, copy, modify, and/or distribute this software for anypurpose with or without fee is hereby granted, provided that the abovecopyright notice and this permission notice appear in all copies.THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIESWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OFMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FORANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGESWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN ANACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OFOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
</pre></body>
</html>
